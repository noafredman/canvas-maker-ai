<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CanvasMaker HTML Rendering Test</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }
        
        .controls button {
            margin: 5px;
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .controls button:hover {
            background: #0056b3;
        }
        
        .canvas-wrapper {
            width: 100%;
            height: 600px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }
        
        #canvas {
            border: 1px solid #ccc;
            background: white;
            display: block;
        }

        /* Floating Toolbar Styles */
        .floating-toolbar {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            user-select: none;
        }

        .toolbar-drag-handle {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            cursor: move;
            color: #666;
            opacity: 0.6;
        }

        .toolbar-content {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: rgba(0, 0, 0, 0.1);
            margin: 0 4px;
        }

        .tool-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            color: #666;
            transition: all 0.15s ease;
        }

        .tool-btn:hover {
            background: rgba(59, 130, 246, 0.1);
            color: #3b82f6;
        }

        .tool-btn.active {
            background: #3b82f6;
            color: white;
        }

        .clear-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            color: #666;
            transition: all 0.15s ease;
        }

        .clear-btn:hover {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
        }

        .canvas-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(12px);
            border-radius: 8px;
            padding: 4px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }

        .zoom-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            border: none;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            color: #666;
        }

        .zoom-indicator {
            padding: 0 8px;
            font-size: 11px;
            font-weight: 500;
            color: #666;
            min-width: 35px;
            text-align: center;
        }

        .selection-box {
            position: absolute;
            border: 2px dashed #3b82f6;
            background: rgba(59, 130, 246, 0.1);
            pointer-events: none;
            display: none;
        }
        
        .log {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        /* Style for HTML rendered components */
        .react-component-html {
            border: 1px dashed #007bff;
            transition: all 0.15s ease;
        }
        
        .react-component-html:hover {
            border-color: #0056b3;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .react-component-html.editing {
            border: 2px solid #3b82f6;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .react-component-html button {
            width: 100%;
            height: 100%;
            border: 2px solid #000;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .react-component-html button:hover {
            transform: scale(1.05);
            transition: transform 0.2s;
        }
        
        .react-component-html .card {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-sizing: border-box;
        }
        
        .react-component-html .card h3 {
            margin: 0 0 5px 0;
            font-size: 16px;
        }
        
        .react-component-html .card p {
            margin: 0;
            font-size: 12px;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CanvasMaker HTML Rendering Test</h1>
        <p>Testing HTML rendering for React component shapes</p>
        
        <div class="controls">
            <button onclick="addButton()">Add Button Component</button>
            <button onclick="addCard()">Add Card Component</button>
            <button onclick="addForm()">Add Form Component</button>
            <button onclick="addCenterButton()">Add Button at World (0,0)</button>
            <button onclick="addExactCenterButton()">Add Button at Exact Canvas Center</button>
            <button onclick="addScrollableForm()">Add Scrollable Form (Large Content)</button>
            <button onclick="testScrollableFeatures()" style="background: #17a2b8;">üîÑ Test Scrollable Features</button>
            <button onclick="testPersistence()" style="background: #6f42c1;">üíæ Test Persistence</button>
            <button onclick="testGranularClear()" style="background: #fd7e14;">üßπ Test Granular Clear</button>
            <button onclick="testResizeLimits()" style="background: #20c997;">üìè Test Resize Limits</button>
            <button onclick="testClearBug()" style="background: #dc3545;">üêõ Test Clear Bug</button>
            <button onclick="testExternalConstraintAPI()" style="background: #6c757d;">‚öôÔ∏è Test External Constraint API</button>
            <button onclick="clearComponents()">Clear All (Old Method)</button>
            <button onclick="testEnhancedClear()" style="background: #e74c3c;">üß™ Test Enhanced Clear()</button>
            <button onclick="testClearHTMLComponentsOnly()" style="background: #20c997;">üéØ Test Clear HTML Only</button>
            <button onclick="testBasicDrawing()" style="background: #17a2b8;">üé® Test Basic Drawing</button>
            <button onclick="testZoom()">Test Zoom</button>
            <button onclick="testPan()">Test Pan</button>
            <br>
            <small style="color: #666; margin-top: 10px; display: block;">
                <strong>Instructions:</strong> 
                ‚Ä¢ Single-click to select/drag components<br>
                ‚Ä¢ Double-click to enter edit mode (interact with buttons/forms)<br>
                ‚Ä¢ In edit mode, components with overflow content will show scrollbars<br>
                ‚Ä¢ Press ESC or click outside to exit edit mode<br>
                ‚Ä¢ Use "Test Scrollable Features" to analyze overflow in components<br>
                ‚Ä¢ Use "Test Persistence" to demo state export/import and filtering<br>
                ‚Ä¢ Use "Test Granular Clear" to demo selective clearing methods<br>
                ‚Ä¢ Use "Test Resize Limits" to demo constrained resizing with min/max bounds<br>
                ‚Ä¢ Use "Test External Constraint API" to see how outer apps can control constraints
            </small>
        </div>
        
        <div class="canvas-wrapper" id="canvas-container">
            <canvas id="canvas" width="800" height="600"></canvas>
            <div id="selection-box" class="selection-box"></div>
            
            <!-- Floating Toolbar -->
            <div id="floating-toolbar" class="floating-toolbar">
                <div class="toolbar-drag-handle" id="toolbar-drag-handle">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                        <circle cx="5" cy="7" r="1"/>
                        <circle cx="12" cy="7" r="1"/>
                        <circle cx="19" cy="7" r="1"/>
                        <circle cx="5" cy="12" r="1"/>
                        <circle cx="12" cy="12" r="1"/>
                        <circle cx="19" cy="12" r="1"/>
                        <circle cx="5" cy="17" r="1"/>
                        <circle cx="12" cy="17" r="1"/>
                        <circle cx="19" cy="17" r="1"/>
                    </svg>
                </div>
                
                <div class="toolbar-content">
                    <div class="toolbar-section">
                        <button id="pen-tool" class="tool-btn" data-tool="pen" title="Pen Tool">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                            </svg>
                        </button>
                        <button id="rectangle-tool" class="tool-btn" data-tool="rectangle" title="Rectangle Tool">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M3 3v18h18V3H3zm16 16H5V5h14v14z"/>
                            </svg>
                        </button>
                        <button id="circle-tool" class="tool-btn" data-tool="circle" title="Circle Tool">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="2" fill="none"/>
                            </svg>
                        </button>
                        <button id="text-tool" class="tool-btn" data-tool="text" title="Text Tool">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M5 4v3h5.5v12h3V7H19V4z"/>
                            </svg>
                        </button>
                        <button id="select-tool" class="tool-btn active" data-tool="select" title="Select Tool">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M2 2v6h2V4h4V2H2zm0 16v-6h2v4h4v2H2zm20 0h-6v2h4v-4h2v6zm0-16V2h-6v2h4v4h2V6z"/>
                            </svg>
                        </button>
                    </div>
                    
                    <div class="toolbar-divider"></div>
                    
                    <div class="toolbar-section">
                        <button id="clear-btn" class="clear-btn" title="Clear Canvas">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="canvas-controls">
                <div class="zoom-controls">
                    <button id="zoom-out-btn" class="zoom-btn">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M19 13H5v-2h14v2z"/>
                        </svg>
                    </button>
                    <div id="zoom-indicator" class="zoom-indicator">100%</div>
                    <button id="zoom-in-btn" class="zoom-btn">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                        </svg>
                    </button>
                </div>
                <button id="recenter-btn" class="recenter-btn" style="display: none;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" fill="none"/>
                        <circle cx="12" cy="12" r="6" stroke="currentColor" stroke-width="2" fill="none"/>
                        <circle cx="12" cy="12" r="2" fill="currentColor"/>
                    </svg>
                </button>
                <button id="reset-zoom-btn" class="recenter-btn" style="display: none;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                        <text x="9.5" y="11" text-anchor="middle" font-size="6" font-weight="bold" fill="currentColor">100</text>
                    </svg>
                </button>
            </div>
        </div>
        
        <div class="log" id="log">
            <div><strong>Log:</strong></div>
        </div>
    </div>

    <script src="canvas.js"></script>
    <script>
        let canvasMaker;
        let componentCount = 0;
        
        // Initialize CanvasMaker - wait for the auto-created instance
        function initializeCanvas() {
            // Wait for the auto-created CanvasMaker instance
            const waitForCanvasMaker = () => {
                if (window.canvasMaker) {
                    canvasMaker = window.canvasMaker;
                    log('Found auto-created CanvasMaker instance');
                    log(`Canvas: ${canvasMaker.canvas ? canvasMaker.canvas.width + 'x' + canvasMaker.canvas.height : 'NOT FOUND'}`);
                    
                    // Listen for component clicks
                    if (canvasMaker.canvas) {
                        canvasMaker.canvas.addEventListener('canvasComponentClick', (e) => {
                            log(`Component clicked: ${e.detail.shape.id}`);
                        });
                    }
                    
                    // Test basic functionality
                    setTimeout(() => {
                        addCenterButton();
                        setTimeout(() => {
                            addCard();
                        }, 500);
                    }, 100);
                } else {
                    // Try again in 100ms
                    setTimeout(waitForCanvasMaker, 100);
                }
            };
            waitForCanvasMaker();
        }
        
        // Add a button component
        function addButton() {
            componentCount++;
            // First component goes exactly at center, others get random offsets
            const offsetX = componentCount === 1 ? 0 : (Math.random() - 0.5) * 200;
            const offsetY = componentCount === 1 ? 0 : (Math.random() - 0.5) * 200;
            
            const buttonHTML = `<button onclick="alert('Button ${componentCount} clicked!')">Button ${componentCount}</button>`;
            
            const shape = canvasMaker.addReactComponentWithHTML(offsetX, offsetY, 120, 40, buttonHTML, {
                id: 'button-' + componentCount,
                fill: '#ff6b6b', // Red for random buttons
                coordinateSystem: 'center'
            });
            
            if (componentCount === 1) {
                log(`Added button component #${componentCount} at EXACT CENTER (0, 0)`);
            } else {
                log(`Added button component #${componentCount} at center + (${offsetX}, ${offsetY}) [rounded: (${offsetX.toFixed(0)}, ${offsetY.toFixed(0)})]`);
            }
            return shape;
        }
        
        // Add a card component
        function addCard() {
            componentCount++;
            // First component goes exactly at center, others get random offsets
            const offsetX = componentCount === 1 ? 0 : (Math.random() - 0.5) * 300;
            const offsetY = componentCount === 1 ? 0 : (Math.random() - 0.5) * 200;
            
            const cardHTML = `
                <div class="card">
                    <h3>Card ${componentCount}</h3>
                    <p>This is a React component rendered as HTML on the canvas</p>
                </div>
            `;
            
            const shape = canvasMaker.addReactComponentWithHTML(offsetX, offsetY, 200, 120, cardHTML, {
                id: 'card-' + componentCount,
                fill: 'transparent',
                coordinateSystem: 'center'
            });
            
            if (componentCount === 1) {
                log(`Added card component #${componentCount} at EXACT CENTER (0, 0)`);
            } else {
                log(`Added card component #${componentCount} at center + (${offsetX.toFixed(0)}, ${offsetY.toFixed(0)})`);
            }
            return shape;
        }
        
        // Add a form component
        function addForm() {
            componentCount++;
            // First component goes exactly at center, others get random offsets
            const offsetX = componentCount === 1 ? 0 : (Math.random() - 0.5) * 300;
            const offsetY = componentCount === 1 ? 0 : (Math.random() - 0.5) * 200;
            
            const formHTML = `
                <div style="padding: 8px; background: white; border-radius: 6px; height: 100%; box-sizing: border-box; overflow: hidden; display: flex; flex-direction: column; justify-content: center;">
                    <h4 style="margin: 0 0 6px 0; color: #333; font-size: 14px; line-height: 1.2;">Form ${componentCount}</h4>
                    <input type="text" placeholder="Enter text" style="width: 100%; margin-bottom: 6px; padding: 3px; border: 1px solid #ccc; border-radius: 3px; font-size: 12px; box-sizing: border-box;">
                    <button style="width: 100%; padding: 4px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px; box-sizing: border-box;">Submit</button>
                </div>
            `;
            
            const shape = canvasMaker.addReactComponentWithHTML(offsetX, offsetY, 180, 100, formHTML, {
                id: 'form-' + componentCount,
                fill: '#f8f9fa',
                coordinateSystem: 'center'
            });
            
            if (componentCount === 1) {
                log(`Added form component #${componentCount} at EXACT CENTER (0, 0)`);
            } else {
                log(`Added form component #${componentCount} at center + (${offsetX.toFixed(0)}, ${offsetY.toFixed(0)})`);
            }
            return shape;
        }
        
        // Add a button at exact canvas center using center coordinate system
        function addExactCenterButton() {
            componentCount++;
            
            const buttonHTML = `<button onclick="alert('Exact Center Button ${componentCount} clicked!')">Exact Center ${componentCount}</button>`;
            
            // Use center coordinates with zero offset for exact canvas center
            const shape = canvasMaker.addReactComponentWithHTML(0, 0, 160, 40, buttonHTML, {
                id: 'exact-center-' + componentCount,
                fill: '#9b59b6',
                coordinateSystem: 'center'
            });
            
            log(`Added button at exact canvas center using coordinateSystem: 'center' with (0, 0) offset`);
            return shape;
        }
        
        // Add a button at exact center using helper method
        function addCenterButton() {
            componentCount++;
            
            const buttonHTML = `<button onclick="alert('Center Button ${componentCount} clicked!')">Center Button ${componentCount}</button>`;
            
            // Use world coordinates (0, 0) for exact center
            const shape = canvasMaker.addReactComponentWithHTML(0, 0, 140, 40, buttonHTML, {
                id: 'center-button-' + componentCount,
                fill: '#e74c3c',
                coordinateSystem: 'world'
            });
            
            log(`Added button at exact world center (0, 0)`);
            return shape;
        }
        
        // Clear all components (old method)
        function clearComponents() {
            // Get all reactComponent shapes
            const reactShapes = canvasMaker.activeCanvasContext.shapes.filter(s => s.type === 'reactComponent');
            
            // Remove each one
            reactShapes.forEach(shape => {
                canvasMaker.removeReactComponent(shape);
            });
            
            componentCount = 0;
            log('Cleared all components (old method)');
        }
        
        // Test the enhanced clear() method
        function testEnhancedClear() {
            log('üß™ TESTING ENHANCED CLEAR() METHOD');
            log('- Before clear: Checking state...');
            
            // Show current state
            const shapes = canvasMaker.activeCanvasContext.shapes.length;
            const htmlComponents = canvasMaker.htmlComponents ? canvasMaker.htmlComponents.size : 0;
            const selectedElements = canvasMaker.activeCanvasContext.selectedElements.length;
            
            log(`  ‚Ä¢ Canvas shapes: ${shapes}`);
            log(`  ‚Ä¢ HTML components: ${htmlComponents}`);
            log(`  ‚Ä¢ Selected elements: ${selectedElements}`);
            log(`  ‚Ä¢ Current tool: ${canvasMaker.currentTool || 'none'}`);
            log(`  ‚Ä¢ Is dragging: ${canvasMaker.isDragging}`);
            log(`  ‚Ä¢ Is editing component: ${canvasMaker.editingComponentId || 'none'}`);
            
            // Call the enhanced clear method
            log('- Calling canvasMaker.clear()...');
            canvasMaker.clear();
            
            // Check state after clear
            setTimeout(() => {
                const shapesAfter = canvasMaker.activeCanvasContext.shapes.length;
                const htmlComponentsAfter = canvasMaker.htmlComponents ? canvasMaker.htmlComponents.size : 0;
                const selectedElementsAfter = canvasMaker.activeCanvasContext.selectedElements.length;
                
                log('- After clear: Checking state...');
                log(`  ‚Ä¢ Canvas shapes: ${shapesAfter} (should be 0)`);
                log(`  ‚Ä¢ HTML components: ${htmlComponentsAfter} (should be 0)`);
                log(`  ‚Ä¢ Selected elements: ${selectedElementsAfter} (should be 0)`);
                log(`  ‚Ä¢ Current tool: ${canvasMaker.currentTool || 'none'}`);
                log(`  ‚Ä¢ Is dragging: ${canvasMaker.isDragging}`);
                log(`  ‚Ä¢ Is editing component: ${canvasMaker.editingComponentId || 'none'}`);
                
                // Verify success
                const success = shapesAfter === 0 && htmlComponentsAfter === 0 && selectedElementsAfter === 0;
                if (success) {
                    log('‚úÖ ENHANCED CLEAR() TEST PASSED - Everything cleared successfully!');
                } else {
                    log('‚ùå ENHANCED CLEAR() TEST FAILED - Some elements remain');
                }
                
                componentCount = 0;
            }, 100);
        }
        
        // Test zoom functionality
        function testZoom() {
            log('Testing zoom - zooming in...');
            canvasMaker.zoomIn();
            
            setTimeout(() => {
                log('Zooming out...');
                canvasMaker.zoomOut();
            }, 1000);
        }
        
        // Test pan functionality  
        function testPan() {
            log('Testing pan - moving camera...');
            const camera = canvasMaker.activeCanvasContext.camera;
            const originalX = camera.x;
            const originalY = camera.y;
            
            // Pan right and down
            camera.x += 100;
            camera.y += 50;
            canvasMaker.redrawCanvas();
            
            setTimeout(() => {
                log('Returning to original position...');
                camera.x = originalX;
                camera.y = originalY;
                canvasMaker.redrawCanvas();
            }, 1000);
        }
        
        // Add a form with content that overflows the container
        function addScrollableForm() {
            componentCount++;
            const offsetX = componentCount === 1 ? 0 : (Math.random() - 0.5) * 300;
            const offsetY = componentCount === 1 ? 0 : (Math.random() - 0.5) * 200;
            
            // Create large form content that will overflow
            const formHTML = `
                <div style="padding: 10px; background: white; border-radius: 6px; box-sizing: border-box; min-height: 100%;">
                    <h3 style="margin: 0 0 10px 0; color: #333;">Large Form ${componentCount}</h3>
                    <p style="margin-bottom: 10px; font-size: 12px;">This form has more content than can fit in the container. Double-click to enable scrolling.</p>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; font-weight: bold; margin-bottom: 5px;">Name:</label>
                        <input type="text" placeholder="Enter your name" style="width: 100%; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; font-weight: bold; margin-bottom: 5px;">Email:</label>
                        <input type="email" placeholder="Enter your email" style="width: 100%; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; font-weight: bold; margin-bottom: 5px;">Message:</label>
                        <textarea placeholder="Enter your message here..." style="width: 100%; height: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 3px; resize: none;"></textarea>
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                            <input type="checkbox" style="margin-right: 5px;"> I agree to the terms and conditions
                        </label>
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; font-weight: bold; margin-bottom: 5px;">Priority:</label>
                        <select style="width: 100%; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                            <option>Low</option>
                            <option>Medium</option>
                            <option>High</option>
                            <option>Urgent</option>
                        </select>
                    </div>
                    
                    <div style="display: flex; gap: 10px;">
                        <button style="flex: 1; padding: 8px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">Submit</button>
                        <button style="flex: 1; padding: 8px; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer;">Cancel</button>
                    </div>
                    
                    <div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 3px; font-size: 11px; color: #666;">
                        This is additional content to demonstrate scrolling functionality when the content exceeds the container height.
                    </div>
                </div>
            `;
            
            const shape = canvasMaker.addReactComponentWithHTML(offsetX, offsetY, 250, 200, formHTML, {
                id: 'scrollable-form-' + componentCount,
                fill: '#f8f9fa',
                coordinateSystem: 'center'
            });
            
            log(`Added large scrollable form #${componentCount} - Double-click to enable scrolling`);
            return shape;
        }
        
        // Test scrollable features
        function testScrollableFeatures() {
            log('üîÑ TESTING SCROLLABLE FEATURES');
            
            // Find all React components
            const reactShapes = canvasMaker.activeCanvasContext.shapes.filter(s => s.type === 'reactComponent');
            
            if (reactShapes.length === 0) {
                log('‚ùå No React components found. Add some components first.');
                return;
            }
            
            reactShapes.forEach((shape, index) => {
                log(`- Component ${shape.id}:`);
                
                // Check overflow info
                const overflowInfo = canvasMaker.getComponentOverflowInfo(shape.id);
                const hasOverflow = canvasMaker.hasComponentOverflow(shape.id);
                
                log(`  ‚Ä¢ Has overflow: ${hasOverflow}`);
                if (overflowInfo) {
                    log(`  ‚Ä¢ Content size: ${overflowInfo.scrollWidth}x${overflowInfo.scrollHeight}`);
                    log(`  ‚Ä¢ Container size: ${overflowInfo.clientWidth}x${overflowInfo.clientHeight}`);
                    log(`  ‚Ä¢ Horizontal overflow: ${overflowInfo.horizontal}`);
                    log(`  ‚Ä¢ Vertical overflow: ${overflowInfo.vertical}`);
                    
                    // Test setting scrollable size for components with overflow
                    if (hasOverflow) {
                        log(`  ‚Ä¢ Setting custom scrollable size for ${shape.id}`);
                        const success = canvasMaker.setComponentScrollableSize(shape.id, 200, 150);
                        log(`  ‚Ä¢ Size update ${success ? 'succeeded' : 'failed'}`);
                    }
                } else {
                    log(`  ‚Ä¢ No overflow info available`);
                }
            });
            
            log('‚úÖ Scrollable features test completed. Double-click components with overflow to test scrolling!');
        }
        
        // Test persistence features (export/import state)
        function testPersistence() {
            log('üíæ TESTING PERSISTENCE FEATURES');
            
            // Check if there's content to export
            const shapes = canvasMaker.activeCanvasContext.shapes.length;
            const htmlComponents = canvasMaker.getAllHTMLComponentsData().length;
            
            if (shapes === 0 && htmlComponents === 0) {
                log('‚ö†Ô∏è  No content to test persistence. Add some components first.');
                return;
            }
            
            log(`- Current content: ${shapes} shapes, ${htmlComponents} HTML components`);
            
            // Test individual component data access
            log('- Testing individual component data access:');
            canvasMaker.activeCanvasContext.shapes
                .filter(s => s.type === 'reactComponent')
                .slice(0, 2) // Test first 2 components
                .forEach(shape => {
                    const data = canvasMaker.getHTMLComponentData(shape.id);
                    log(`  ‚Ä¢ ${shape.id}: ${data ? 'SUCCESS' : 'FAILED'} (size: ${data ? data.width + 'x' + data.height : 'N/A'})`);
                });
            
            // Export state
            log('- Exporting canvas state...');
            const exportedState = canvasMaker.exportState();
            log(`  ‚Ä¢ Exported ${exportedState.shapes.length} shapes, ${exportedState.htmlComponents.length} HTML components`);
            log(`  ‚Ä¢ State version: ${exportedState.version}, timestamp: ${new Date(exportedState.timestamp).toLocaleTimeString()}`);
            
            // Test persistence filter
            log('- Setting up persistence filter (exclude buttons):');
            canvasMaker.setPersistenceFilter((item, type) => {
                if (type === 'htmlComponent' && item.id && item.id.includes('button')) {
                    log(`  ‚Ä¢ Filtering out: ${item.id}`);
                    return false;
                }
                return true;
            });
            
            const filteredState = canvasMaker.exportState();
            log(`  ‚Ä¢ Filtered export: ${filteredState.htmlComponents.length} HTML components (${exportedState.htmlComponents.length - filteredState.htmlComponents.length} buttons filtered out)`);
            
            // Clear filter for import test
            canvasMaker.setPersistenceFilter(null);
            
            // Store current camera position
            const originalCamera = { ...canvasMaker.activeCanvasContext.camera };
            
            // Modify camera to test restoration
            canvasMaker.activeCanvasContext.camera.x = 100;
            canvasMaker.activeCanvasContext.camera.y = 50;
            canvasMaker.activeCanvasContext.camera.zoom = 1.5;
            canvasMaker.redrawCanvas();
            
            setTimeout(() => {
                log('- Importing previous state (should restore original camera and content)...');
                const success = canvasMaker.importState(exportedState);
                log(`  ‚Ä¢ Import ${success ? 'succeeded' : 'failed'}`);
                
                if (success) {
                    const restoredShapes = canvasMaker.activeCanvasContext.shapes.length;
                    const restoredComponents = canvasMaker.getAllHTMLComponentsData().length;
                    log(`  ‚Ä¢ Restored: ${restoredShapes} shapes, ${restoredComponents} HTML components`);
                    
                    const camera = canvasMaker.activeCanvasContext.camera;
                    log(`  ‚Ä¢ Camera restored: (${camera.x}, ${camera.y}) zoom: ${camera.zoom}`);
                }
                
                log('‚úÖ Persistence test completed!');
            }, 1000);
        }
        
        // Test granular clear methods
        function testGranularClear() {
            log('üßπ TESTING GRANULAR CLEAR METHODS');
            
            // Ensure we have mixed content
            if (canvasMaker.activeCanvasContext.shapes.length === 0) {
                log('‚ö†Ô∏è  Adding test content for granular clear demo...');
                addButton();
                addCard();
                
                // Add some canvas shapes
                canvasMaker.activeCanvasContext.shapes.push({
                    type: 'rectangle',
                    x: 50,
                    y: 50,
                    width: 100,
                    height: 60,
                    strokeColor: '#333',
                    fillColor: '#f0f0f0'
                });
                
                canvasMaker.activeCanvasContext.shapes.push({
                    type: 'circle',
                    x: -50,
                    y: -50,
                    radius: 40,
                    strokeColor: '#007bff',
                    fillColor: 'transparent'
                });
                
                canvasMaker.redrawCanvas();
                
                setTimeout(() => testGranularClearActual(), 500);
                return;
            }
            
            testGranularClearActual();
        }
        
        function testGranularClearActual() {
            const initialShapes = canvasMaker.activeCanvasContext.shapes.length;
            const initialHtmlComponents = canvasMaker.getAllHTMLComponentsData().length;
            const initialCanvasShapes = canvasMaker.activeCanvasContext.shapes.filter(s => s.type !== 'reactComponent').length;
            
            log(`- Initial content: ${initialShapes} total shapes (${initialHtmlComponents} HTML, ${initialCanvasShapes} canvas shapes)`);
            
            // Test 1: Clear only canvas shapes
            log('- Test 1: clearShapes() - should keep HTML components');
            canvasMaker.clearShapes();
            
            setTimeout(() => {
                const afterShapes = canvasMaker.activeCanvasContext.shapes.length;
                const afterHtmlComponents = canvasMaker.getAllHTMLComponentsData().length;
                log(`  ‚Ä¢ After clearShapes(): ${afterShapes} shapes (${afterHtmlComponents} HTML components remain)`);
                log(`  ‚Ä¢ ${afterHtmlComponents === initialHtmlComponents ? '‚úÖ SUCCESS' : '‚ùå FAILED'} - HTML components preserved`);
                
                // Add canvas shapes back for next test
                canvasMaker.activeCanvasContext.shapes.push({
                    type: 'rectangle',
                    x: 0,
                    y: 100,
                    width: 80,
                    height: 40,
                    strokeColor: '#28a745',
                    fillColor: 'transparent'
                });
                canvasMaker.redrawCanvas();
                
                // Test 2: Clear only HTML components
                setTimeout(() => {
                    log('- Test 2: clearHTMLComponents() - should keep canvas shapes');
                    canvasMaker.clearHTMLComponents();
                    
                    setTimeout(() => {
                        const finalShapes = canvasMaker.activeCanvasContext.shapes.length;
                        const finalHtmlComponents = canvasMaker.getAllHTMLComponentsData().length;
                        const finalCanvasShapes = canvasMaker.activeCanvasContext.shapes.filter(s => s.type !== 'reactComponent').length;
                        
                        log(`  ‚Ä¢ After clearHTMLComponents(): ${finalShapes} shapes (${finalHtmlComponents} HTML, ${finalCanvasShapes} canvas)`);
                        log(`  ‚Ä¢ ${finalHtmlComponents === 0 ? '‚úÖ SUCCESS' : '‚ùå FAILED'} - HTML components cleared`);
                        log(`  ‚Ä¢ ${finalCanvasShapes > 0 ? '‚úÖ SUCCESS' : '‚ùå FAILED'} - Canvas shapes preserved`);
                        
                        // Test 3: Clear all
                        setTimeout(() => {
                            log('- Test 3: clearAll() - should clear everything');
                            canvasMaker.clearAll();
                            
                            const allShapes = canvasMaker.activeCanvasContext.shapes.length;
                            const allHtml = canvasMaker.getAllHTMLComponentsData().length;
                            log(`  ‚Ä¢ After clearAll(): ${allShapes} shapes, ${allHtml} HTML components`);
                            log(`  ‚Ä¢ ${allShapes === 0 && allHtml === 0 ? '‚úÖ SUCCESS' : '‚ùå FAILED'} - Everything cleared`);
                            
                            componentCount = 0;
                            log('‚úÖ Granular clear methods test completed!');
                        }, 500);
                    }, 500);
                }, 1000);
            }, 500);
        }
        
        // Test resize limits and constraints
        function testResizeLimits() {
            log('üìè TESTING RESIZE LIMITS & CONSTRAINTS');
            
            // Clear existing components for clean test
            canvasMaker.clearHTMLComponents();
            
            log('- Setting up test components with different constraint types...');
            
            // 1. Create a component with default constraints
            const defaultComponent = addButton();
            log(`  ‚Ä¢ Default component created: ${defaultComponent.id} (default constraints apply)`);
            
            // 2. Create a component with strict size limits (small range)
            componentCount++;
            const strictHTML = `<div style="padding: 10px; background: #ff6b6b; color: white; text-align: center; border-radius: 4px;">
                <strong>Strict Limits</strong><br>
                <small>Min: 80x40, Max: 150x80</small>
            </div>`;
            
            const strictComponent = canvasMaker.addReactComponentWithHTML(-100, -50, 120, 60, strictHTML, {
                id: 'strict-component-' + componentCount,
                coordinateSystem: 'center',
                resizeConstraints: {
                    minWidth: 80,
                    minHeight: 40,
                    maxWidth: 150,
                    maxHeight: 80
                }
            });
            
            log(`  ‚Ä¢ Strict component created: ${strictComponent.id} (80x40 to 150x80)`);
            
            // 3. Create a component with relaxed limits (large range)
            componentCount++;
            const relaxedHTML = `<div style="padding: 10px; background: #28a745; color: white; text-align: center; border-radius: 4px;">
                <strong>Relaxed Limits</strong><br>
                <small>Min: 100x60, Max: 400x300</small>
            </div>`;
            
            const relaxedComponent = canvasMaker.addReactComponentWithHTML(100, -50, 200, 100, relaxedHTML, {
                id: 'relaxed-component-' + componentCount,
                coordinateSystem: 'center',
                resizeConstraints: {
                    minWidth: 100,
                    minHeight: 60,
                    maxWidth: 400,
                    maxHeight: 300
                }
            });
            
            log(`  ‚Ä¢ Relaxed component created: ${relaxedComponent.id} (100x60 to 400x300)`);
            
            // 4. Set constraints on an existing component
            canvasMaker.setComponentResizeConstraints(defaultComponent.id, {
                minWidth: 60,
                minHeight: 25,
                maxWidth: 200,
                maxHeight: 100
            });
            
            log(`  ‚Ä¢ Updated constraints for ${defaultComponent.id} (60x25 to 200x100)`);
            
            // 5. Test global constraint changes
            log('- Setting global constraints (affects all components without specific constraints)...');
            canvasMaker.setResizeConstraints('reactComponent', {
                minWidth: 75,
                minHeight: 35,
                maxWidth: 300,
                maxHeight: 200
            });
            
            // Show current constraints for each component
            log('- Current constraint summary:');
            [defaultComponent, strictComponent, relaxedComponent].forEach(comp => {
                const constraints = canvasMaker.getResizeConstraints(comp.type, comp);
                log(`  ‚Ä¢ ${comp.id}: ${constraints.minWidth}x${constraints.minHeight} to ${constraints.maxWidth}x${constraints.maxHeight}`);
            });
            
            // Add visual feedback
            setTimeout(() => {
                log('- üéØ TEST INSTRUCTIONS:');
                log('  1. Try to resize each component beyond its limits');
                log('  2. Red component (strict): Very narrow size range');
                log('  3. Green component (relaxed): Wide size range');
                log('  4. Blue component (modified): Custom constraints applied');
                log('  5. Components should stop resizing at min/max limits');
                log('  6. Position should adjust properly when hitting limits');
                
                log('‚úÖ Resize limits test setup completed!');
                log('üí° TIP: Select a component and try dragging the resize handles to test constraints');
            }, 100);
        }
        
        // Test external constraint API with warnings
        function testExternalConstraintAPI() {
            log('‚öôÔ∏è TESTING EXTERNAL CONSTRAINT API');
            
            // Ensure we have at least one component
            if (canvasMaker.getAllHTMLComponentsData().length === 0) {
                log('- Adding a test component first...');
                addButton();
            }
            
            log('- Current global constraints:');
            const currentGlobal = canvasMaker.getCurrentResizeConstraints('global');
            log(`  ‚Ä¢ Global: ${currentGlobal.minWidth}x${currentGlobal.minHeight} to ${currentGlobal.maxWidth}x${currentGlobal.maxHeight}`);
            
            const currentHTML = canvasMaker.getCurrentResizeConstraints('reactComponent');
            log(`  ‚Ä¢ HTML Components: ${currentHTML.minWidth}x${currentHTML.minHeight} to ${currentHTML.maxWidth}x${currentHTML.maxHeight}`);
            
            log('');
            log('- Testing external API methods (check console for detailed warnings)...');
            
            // Test 1: Set reasonable constraints (should show info messages)
            log('1Ô∏è‚É£ Setting reasonable HTML component constraints...');
            canvasMaker.setHTMLComponentConstraints({
                minWidth: 80,
                minHeight: 50,
                maxWidth: 500,
                maxHeight: 400
            });
            
            setTimeout(() => {
                // Test 2: Set concerning constraints (should show warnings)
                log('2Ô∏è‚É£ Setting concerning constraints (very small min, very large max)...');
                canvasMaker.setHTMLComponentConstraints({
                    minWidth: 5,    // Very small - will trigger warning
                    minHeight: 3,   // Very small - will trigger warning
                    maxWidth: 3000, // Very large - will trigger warning
                    maxHeight: 2500 // Very large - will trigger warning
                });
                
                setTimeout(() => {
                    // Test 3: Set invalid constraints (min >= max)
                    log('3Ô∏è‚É£ Setting invalid constraints (min >= max)...');
                    canvasMaker.setHTMLComponentConstraints({
                        minWidth: 200,
                        maxWidth: 150,  // Less than min - will trigger error
                        minHeight: 100,
                        maxHeight: 80   // Less than min - will trigger error
                    });
                    
                    setTimeout(() => {
                        // Test 4: Remove all constraints (should show big warning)
                        log('4Ô∏è‚É£ Removing ALL resize constraints (check console for warnings)...');
                        canvasMaker.removeResizeConstraints('reactComponent');
                        
                        setTimeout(() => {
                            // Test 5: Suppress warnings
                            log('5Ô∏è‚É£ Setting constraints with warnings suppressed...');
                            canvasMaker.setHTMLComponentConstraints({
                                minWidth: 2,
                                maxWidth: 4000
                            }, { suppressWarnings: true });
                            
                            setTimeout(() => {
                                // Test 6: Restore reasonable defaults
                                log('6Ô∏è‚É£ Restoring reasonable defaults...');
                                canvasMaker.setHTMLComponentConstraints({
                                    minWidth: 50,
                                    minHeight: 30,
                                    maxWidth: 1500,
                                    maxHeight: 1000
                                });
                                
                                log('');
                                log('‚úÖ External constraint API test completed!');
                                log('üìã Summary of what happened:');
                                log('  ‚Ä¢ Reasonable constraints: Info messages in console');
                                log('  ‚Ä¢ Concerning values: Warning messages in console');
                                log('  ‚Ä¢ Invalid ranges: Error messages in console');
                                log('  ‚Ä¢ Removing constraints: Big warning about distortion risks');
                                log('  ‚Ä¢ Suppressed warnings: Silent operation');
                                log('  ‚Ä¢ Final restoration: Back to safe defaults');
                                log('');
                                log('üí° TIP: Check the browser console to see all warning messages!');
                            }, 1000);
                        }, 1000);
                    }, 1000);
                }, 1000);
            }, 1000);
        }
        
        // Test clear bug with reactComponent container shapes
        function testClearBug() {
            log('üêõ TESTING CLEAR BUG - ReactComponent Container Persistence');
            
            // First clear everything to start clean
            canvasMaker.clearAll();
            
            log('- Step 1: Testing with addHTMLComponent (outer app approach)...');
            
            // Test what the outer app is doing
            const component = canvasMaker.addHTMLComponent(0, 0, 200, 100, 
                '<div style="padding: 10px; background: #ff6b6b; color: white; text-align: center; border-radius: 4px;"><strong>Test Component</strong><br><small>Should disappear completely after clear()</small></div>', 
                {id: 'test-clear-bug', isReactComponent: true}
            );
            
            log(`  ‚Ä¢ HTML component created: ${component.id}`);
            log(`  ‚Ä¢ Shapes in canvas: ${canvasMaker.activeCanvasContext.shapes.length}`);
            log(`  ‚Ä¢ HTML components: ${canvasMaker.htmlComponents ? canvasMaker.htmlComponents.size : 0}`);
            
            // Show current state details
            const reactShapes = canvasMaker.activeCanvasContext.shapes.filter(s => s.type === 'reactComponent');
            log(`  ‚Ä¢ ReactComponent shapes: ${reactShapes.length}`);
            reactShapes.forEach((shape, i) => {
                log(`    ${i+1}. ID: ${shape.id}, Type: ${shape.type}, Size: ${shape.width}x${shape.height}`);
            });
            
            setTimeout(() => {
                log('- Step 2: Calling clear() method...');
                log('  ‚Ä¢ Before clear() - Visual check: You should see a red component on canvas');
                
                // Call the clear method
                canvasMaker.clear();
                
                setTimeout(() => {
                    log('- Step 3: Checking state after clear()...');
                    
                    const shapesAfter = canvasMaker.activeCanvasContext.shapes.length;
                    const htmlComponentsAfter = canvasMaker.htmlComponents ? canvasMaker.htmlComponents.size : 0;
                    const reactShapesAfter = canvasMaker.activeCanvasContext.shapes.filter(s => s.type === 'reactComponent').length;
                    
                    log(`  ‚Ä¢ Total shapes after clear(): ${shapesAfter}`);
                    log(`  ‚Ä¢ HTML components after clear(): ${htmlComponentsAfter}`);
                    log(`  ‚Ä¢ ReactComponent shapes after clear(): ${reactShapesAfter}`);
                    
                    // Visual verification
                    log('  ‚Ä¢ After clear() - Visual check: Canvas should be completely empty');
                    
                    // Test result
                    const isCleanlyCleared = shapesAfter === 0 && htmlComponentsAfter === 0 && reactShapesAfter === 0;
                    
                    if (isCleanlyCleared) {
                        log('‚úÖ SUCCESS: clear() properly removed all visual elements including reactComponent containers');
                    } else {
                        log('‚ùå BUG CONFIRMED: clear() left some elements behind');
                        log(`   ‚Ä¢ Remaining shapes: ${shapesAfter}`);
                        log(`   ‚Ä¢ Remaining HTML components: ${htmlComponentsAfter}`);
                        log(`   ‚Ä¢ Remaining reactComponent shapes: ${reactShapesAfter}`);
                        
                        if (reactShapesAfter > 0) {
                            log('   üîç ReactComponent shapes still exist - this causes visual container persistence');
                        }
                    }
                    
                    // Force canvas inspection
                    log('- Step 4: Canvas layer inspection...');
                    const canvas = canvasMaker.activeCanvasContext.canvas;
                    const ctx = canvasMaker.activeCanvasContext.ctx;
                    
                    // Get image data to check if canvas is truly empty
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const pixels = imageData.data;
                    let hasVisiblePixels = false;
                    
                    // Check for non-transparent pixels (quick sample check)
                    for (let i = 3; i < pixels.length; i += 4) { // Check alpha channel every 4th element
                        if (pixels[i] > 0) {
                            hasVisiblePixels = true;
                            break;
                        }
                    }
                    
                    log(`  ‚Ä¢ Canvas has visible pixels: ${hasVisiblePixels}`);
                    
                    if (!hasVisiblePixels) {
                        log('‚úÖ Canvas layer is visually clean');
                    } else {
                        log('‚ùå Canvas layer still has visible content');
                    }
                    
                    componentCount = 0;
                    log('');
                    log('üîç BUG TEST COMPLETED - Check results above');
                }, 100);
            }, 1500);
        }
        
        // Logging function
        function log(message) {
            const logDiv = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `<span style="color: #666;">${time}:</span> ${message}`;
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[HTML-RENDER-TEST] ${message}`);
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeCanvas();
            
            // Add a demo component
            setTimeout(() => {
                addButton();
                addCard();
            }, 500);
        });
        
        // Test clearHTMLComponents specifically
        function testClearHTMLComponentsOnly() {
            log('üß™ TESTING clearHTMLComponents() Method');
            
            // Clear only HTML components first, preserve user-drawn shapes
            canvasMaker.clearHTMLComponents();
            
            log('- Step 1: Adding mixed content...');
            
            // Add some regular shapes directly to the shapes array
            canvasMaker.activeCanvasContext.shapes.push({
                type: 'rectangle',
                x: 50,
                y: 50,
                width: 100,
                height: 100,
                fillColor: '#28a745'
            });
            
            canvasMaker.activeCanvasContext.shapes.push({
                type: 'circle',
                x: 200,
                y: 100,
                radius: 50,
                fillColor: '#ffc107'
            });
            
            // Trigger redraw to show the shapes
            canvasMaker.redrawCanvas();
            
            // Add HTML components
            const comp1 = canvasMaker.addHTMLComponent(300, 50, 150, 80,
                '<div style="background: #17a2b8; color: white; padding: 10px; text-align: center;">HTML Component 1</div>',
                { id: 'html-comp-1' }
            );
            
            const comp2 = canvasMaker.addHTMLComponent(300, 150, 150, 80,
                '<div style="background: #6f42c1; color: white; padding: 10px; text-align: center;">HTML Component 2</div>',
                { id: 'html-comp-2' }
            );
            
            log(`  ‚Ä¢ Added 2 regular shapes (rectangle, circle)`);
            log(`  ‚Ä¢ Added 2 HTML components`);
            log(`  ‚Ä¢ Total shapes: ${canvasMaker.activeCanvasContext.shapes.length}`);
            log(`  ‚Ä¢ HTML components: ${canvasMaker.htmlComponents.size}`);
            
            // Debug: Show all shape types
            log('  ‚Ä¢ Shape types before clear:');
            canvasMaker.activeCanvasContext.shapes.forEach((shape, i) => {
                log(`    ${i}: ${shape.type} (${shape.id || 'no-id'})`);
            });
            
            setTimeout(() => {
                log('- Step 2: Calling clearHTMLComponents()...');
                canvasMaker.clearHTMLComponents();
                
                setTimeout(() => {
                    log('- Step 3: Checking results...');
                    
                    const remainingShapes = canvasMaker.activeCanvasContext.shapes.length;
                    const htmlComponents = canvasMaker.htmlComponents.size;
                    const reactShapes = canvasMaker.activeCanvasContext.shapes.filter(s => s.type === 'reactComponent').length;
                    
                    log(`  ‚Ä¢ Remaining shapes: ${remainingShapes}`);
                    log(`  ‚Ä¢ HTML components: ${htmlComponents}`);
                    log(`  ‚Ä¢ ReactComponent shapes: ${reactShapes}`);
                    
                    // Debug: Show remaining shape types
                    log('  ‚Ä¢ Remaining shape types:');
                    canvasMaker.activeCanvasContext.shapes.forEach((shape, i) => {
                        log(`    ${i}: ${shape.type} (${shape.id || 'no-id'})`);
                    });
                    
                    if (htmlComponents === 0 && reactShapes === 0 && remainingShapes === 2) {
                        log('‚úÖ SUCCESS: clearHTMLComponents() works correctly!');
                        log('  - HTML components removed');
                        log('  - Regular shapes preserved');
                    } else {
                        log('‚ùå ISSUE: clearHTMLComponents() did not work as expected');
                        if (htmlComponents > 0) log('  - HTML components still present');
                        if (reactShapes > 0) log('  - ReactComponent shapes still present');
                        if (remainingShapes !== 2) log(`  - Wrong number of remaining shapes (expected 2, got ${remainingShapes})`);
                    }
                }, 500);
            }, 1500);
        }

        // Debug function to test basic canvas drawing
        function testBasicDrawing() {
            log('üé® Testing basic canvas drawing...');
            
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // Clear and draw a test rectangle
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'red';
            ctx.fillRect(50, 50, 100, 100);
            
            // Draw a test circle
            ctx.fillStyle = 'blue';
            ctx.beginPath();
            ctx.arc(200, 100, 30, 0, Math.PI * 2);
            ctx.fill();
            
            log('  ‚Ä¢ Drew test shapes directly on canvas');
            log(`  ‚Ä¢ Canvas dimensions: ${canvas.width} x ${canvas.height}`);
            
            // Test CanvasMaker state
            if (canvasMaker) {
                log(`  ‚Ä¢ CanvasMaker shapes: ${canvasMaker.activeCanvasContext.shapes.length}`);
                log(`  ‚Ä¢ HTML components: ${canvasMaker.htmlComponents.size}`);
                log(`  ‚Ä¢ Canvas element: ${canvasMaker.canvas ? 'found' : 'NOT FOUND'}`);
                log(`  ‚Ä¢ HTML layer: ${canvasMaker.htmlRenderingLayer ? 'found' : 'NOT FOUND'}`);
                
                // Debug: Show all shapes in all contexts
                log('  ‚Ä¢ Main context shapes:', canvasMaker.mainCanvasContext ? canvasMaker.mainCanvasContext.shapes.length : 'no main');
                log('  ‚Ä¢ Nested context shapes:', canvasMaker.nestedCanvasContext ? canvasMaker.nestedCanvasContext.shapes.length : 'no nested');
                log('  ‚Ä¢ Active context shapes:', canvasMaker.activeCanvasContext.shapes.length);
                log('  ‚Ä¢ Active context is main:', canvasMaker.activeCanvasContext === canvasMaker.mainCanvasContext);
                
                // Show shapes in active context
                if (canvasMaker.activeCanvasContext.shapes.length > 0) {
                    log('  ‚Ä¢ Active context shape types:');
                    canvasMaker.activeCanvasContext.shapes.forEach((shape, i) => {
                        log(`    ${i}: ${shape.type} (${shape.id || 'no-id'})`);
                    });
                }
                
                // Try to restore CanvasMaker rendering
                setTimeout(() => {
                    log('  ‚Ä¢ Calling CanvasMaker redraw to restore grid...');
                    canvasMaker.redrawCanvas();
                    log('  ‚Ä¢ Grid should be restored now');
                }, 1000);
            }
        }

        // Monitor for HTML components
        setInterval(() => {
            if (canvasMaker && canvasMaker.htmlComponents) {
                const count = canvasMaker.htmlComponents.size;
                const status = document.querySelector('#component-status');
                if (!status) {
                    const statusDiv = document.createElement('div');
                    statusDiv.id = 'component-status';
                    statusDiv.style.cssText = 'position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 8px; border-radius: 4px; font-size: 12px;';
                    document.body.appendChild(statusDiv);
                }
                document.getElementById('component-status').textContent = `HTML Components: ${count}`;
            }
        }, 1000);
    </script>
</body>
</html>