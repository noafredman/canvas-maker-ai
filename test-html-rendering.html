<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CanvasMaker HTML Rendering Test</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }
        
        .controls button {
            margin: 5px;
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .controls button:hover {
            background: #0056b3;
        }
        
        .canvas-wrapper {
            width: 100%;
            height: 600px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }
        
        .log {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        /* Style for HTML rendered components */
        .react-component-html {
            border: 1px dashed #007bff;
            transition: all 0.15s ease;
        }
        
        .react-component-html:hover {
            border-color: #0056b3;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .react-component-html.editing {
            border: 2px solid #3b82f6;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .react-component-html button {
            width: 100%;
            height: 100%;
            border: 2px solid #000;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .react-component-html button:hover {
            transform: scale(1.05);
            transition: transform 0.2s;
        }
        
        .react-component-html .card {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-sizing: border-box;
        }
        
        .react-component-html .card h3 {
            margin: 0 0 5px 0;
            font-size: 16px;
        }
        
        .react-component-html .card p {
            margin: 0;
            font-size: 12px;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CanvasMaker HTML Rendering Test</h1>
        <p>Testing HTML rendering for React component shapes</p>
        
        <div class="controls">
            <button onclick="addButton()">Add Button Component</button>
            <button onclick="addCard()">Add Card Component</button>
            <button onclick="addForm()">Add Form Component</button>
            <button onclick="addCenterButton()">Add Button at World (0,0)</button>
            <button onclick="addExactCenterButton()">Add Button at Exact Canvas Center</button>
            <button onclick="addScrollableForm()">Add Scrollable Form (Large Content)</button>
            <button onclick="testScrollableFeatures()" style="background: #17a2b8;">üîÑ Test Scrollable Features</button>
            <button onclick="testPersistence()" style="background: #6f42c1;">üíæ Test Persistence</button>
            <button onclick="testGranularClear()" style="background: #fd7e14;">üßπ Test Granular Clear</button>
            <button onclick="testResizeLimits()" style="background: #20c997;">üìè Test Resize Limits</button>
            <button onclick="testExternalConstraintAPI()" style="background: #6c757d;">‚öôÔ∏è Test External Constraint API</button>
            <button onclick="clearComponents()">Clear All (Old Method)</button>
            <button onclick="testEnhancedClear()" style="background: #e74c3c;">üß™ Test Enhanced Clear()</button>
            <button onclick="testZoom()">Test Zoom</button>
            <button onclick="testPan()">Test Pan</button>
            <br>
            <small style="color: #666; margin-top: 10px; display: block;">
                <strong>Instructions:</strong> 
                ‚Ä¢ Single-click to select/drag components<br>
                ‚Ä¢ Double-click to enter edit mode (interact with buttons/forms)<br>
                ‚Ä¢ In edit mode, components with overflow content will show scrollbars<br>
                ‚Ä¢ Press ESC or click outside to exit edit mode<br>
                ‚Ä¢ Use "Test Scrollable Features" to analyze overflow in components<br>
                ‚Ä¢ Use "Test Persistence" to demo state export/import and filtering<br>
                ‚Ä¢ Use "Test Granular Clear" to demo selective clearing methods<br>
                ‚Ä¢ Use "Test Resize Limits" to demo constrained resizing with min/max bounds<br>
                ‚Ä¢ Use "Test External Constraint API" to see how outer apps can control constraints
            </small>
        </div>
        
        <div class="canvas-wrapper" id="canvas-container"></div>
        
        <div class="log" id="log">
            <div><strong>Log:</strong></div>
        </div>
    </div>

    <script src="canvas.js"></script>
    <script>
        let canvasMaker;
        let componentCount = 0;
        
        // Initialize CanvasMaker
        function initializeCanvas() {
            const container = document.getElementById('canvas-container');
            canvasMaker = new CanvasMaker(container, {
                width: 1000,
                height: 600,
                createToolbar: true
            });
            
            log('CanvasMaker initialized with HTML rendering support');
            
            // Listen for component clicks
            canvasMaker.canvas.addEventListener('canvasComponentClick', (e) => {
                log(`Component clicked: ${e.detail.shape.id}`);
            });
        }
        
        // Add a button component
        function addButton() {
            componentCount++;
            // First component goes exactly at center, others get random offsets
            const offsetX = componentCount === 1 ? 0 : (Math.random() - 0.5) * 200;
            const offsetY = componentCount === 1 ? 0 : (Math.random() - 0.5) * 200;
            
            const buttonHTML = `<button onclick="alert('Button ${componentCount} clicked!')">Button ${componentCount}</button>`;
            
            const shape = canvasMaker.addReactComponentWithHTML(offsetX, offsetY, 120, 40, buttonHTML, {
                id: 'button-' + componentCount,
                fill: '#ff6b6b', // Red for random buttons
                coordinateSystem: 'center'
            });
            
            if (componentCount === 1) {
                log(`Added button component #${componentCount} at EXACT CENTER (0, 0)`);
            } else {
                log(`Added button component #${componentCount} at center + (${offsetX}, ${offsetY}) [rounded: (${offsetX.toFixed(0)}, ${offsetY.toFixed(0)})]`);
            }
            return shape;
        }
        
        // Add a card component
        function addCard() {
            componentCount++;
            // First component goes exactly at center, others get random offsets
            const offsetX = componentCount === 1 ? 0 : (Math.random() - 0.5) * 300;
            const offsetY = componentCount === 1 ? 0 : (Math.random() - 0.5) * 200;
            
            const cardHTML = `
                <div class="card">
                    <h3>Card ${componentCount}</h3>
                    <p>This is a React component rendered as HTML on the canvas</p>
                </div>
            `;
            
            const shape = canvasMaker.addReactComponentWithHTML(offsetX, offsetY, 200, 120, cardHTML, {
                id: 'card-' + componentCount,
                fill: 'transparent',
                coordinateSystem: 'center'
            });
            
            if (componentCount === 1) {
                log(`Added card component #${componentCount} at EXACT CENTER (0, 0)`);
            } else {
                log(`Added card component #${componentCount} at center + (${offsetX.toFixed(0)}, ${offsetY.toFixed(0)})`);
            }
            return shape;
        }
        
        // Add a form component
        function addForm() {
            componentCount++;
            // First component goes exactly at center, others get random offsets
            const offsetX = componentCount === 1 ? 0 : (Math.random() - 0.5) * 300;
            const offsetY = componentCount === 1 ? 0 : (Math.random() - 0.5) * 200;
            
            const formHTML = `
                <div style="padding: 8px; background: white; border-radius: 6px; height: 100%; box-sizing: border-box; overflow: hidden; display: flex; flex-direction: column; justify-content: center;">
                    <h4 style="margin: 0 0 6px 0; color: #333; font-size: 14px; line-height: 1.2;">Form ${componentCount}</h4>
                    <input type="text" placeholder="Enter text" style="width: 100%; margin-bottom: 6px; padding: 3px; border: 1px solid #ccc; border-radius: 3px; font-size: 12px; box-sizing: border-box;">
                    <button style="width: 100%; padding: 4px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px; box-sizing: border-box;">Submit</button>
                </div>
            `;
            
            const shape = canvasMaker.addReactComponentWithHTML(offsetX, offsetY, 180, 100, formHTML, {
                id: 'form-' + componentCount,
                fill: '#f8f9fa',
                coordinateSystem: 'center'
            });
            
            if (componentCount === 1) {
                log(`Added form component #${componentCount} at EXACT CENTER (0, 0)`);
            } else {
                log(`Added form component #${componentCount} at center + (${offsetX.toFixed(0)}, ${offsetY.toFixed(0)})`);
            }
            return shape;
        }
        
        // Add a button at exact canvas center using center coordinate system
        function addExactCenterButton() {
            componentCount++;
            
            const buttonHTML = `<button onclick="alert('Exact Center Button ${componentCount} clicked!')">Exact Center ${componentCount}</button>`;
            
            // Use center coordinates with zero offset for exact canvas center
            const shape = canvasMaker.addReactComponentWithHTML(0, 0, 160, 40, buttonHTML, {
                id: 'exact-center-' + componentCount,
                fill: '#9b59b6',
                coordinateSystem: 'center'
            });
            
            log(`Added button at exact canvas center using coordinateSystem: 'center' with (0, 0) offset`);
            return shape;
        }
        
        // Add a button at exact center using helper method
        function addCenterButton() {
            componentCount++;
            
            const buttonHTML = `<button onclick="alert('Center Button ${componentCount} clicked!')">Center Button ${componentCount}</button>`;
            
            // Use world coordinates (0, 0) for exact center
            const shape = canvasMaker.addReactComponentWithHTML(0, 0, 140, 40, buttonHTML, {
                id: 'center-button-' + componentCount,
                fill: '#e74c3c',
                coordinateSystem: 'world'
            });
            
            log(`Added button at exact world center (0, 0)`);
            return shape;
        }
        
        // Clear all components (old method)
        function clearComponents() {
            // Get all reactComponent shapes
            const reactShapes = canvasMaker.activeCanvasContext.shapes.filter(s => s.type === 'reactComponent');
            
            // Remove each one
            reactShapes.forEach(shape => {
                canvasMaker.removeReactComponent(shape);
            });
            
            componentCount = 0;
            log('Cleared all components (old method)');
        }
        
        // Test the enhanced clear() method
        function testEnhancedClear() {
            log('üß™ TESTING ENHANCED CLEAR() METHOD');
            log('- Before clear: Checking state...');
            
            // Show current state
            const shapes = canvasMaker.activeCanvasContext.shapes.length;
            const htmlComponents = canvasMaker.htmlComponents ? canvasMaker.htmlComponents.size : 0;
            const selectedElements = canvasMaker.activeCanvasContext.selectedElements.length;
            
            log(`  ‚Ä¢ Canvas shapes: ${shapes}`);
            log(`  ‚Ä¢ HTML components: ${htmlComponents}`);
            log(`  ‚Ä¢ Selected elements: ${selectedElements}`);
            log(`  ‚Ä¢ Current tool: ${canvasMaker.currentTool || 'none'}`);
            log(`  ‚Ä¢ Is dragging: ${canvasMaker.isDragging}`);
            log(`  ‚Ä¢ Is editing component: ${canvasMaker.editingComponentId || 'none'}`);
            
            // Call the enhanced clear method
            log('- Calling canvasMaker.clear()...');
            canvasMaker.clear();
            
            // Check state after clear
            setTimeout(() => {
                const shapesAfter = canvasMaker.activeCanvasContext.shapes.length;
                const htmlComponentsAfter = canvasMaker.htmlComponents ? canvasMaker.htmlComponents.size : 0;
                const selectedElementsAfter = canvasMaker.activeCanvasContext.selectedElements.length;
                
                log('- After clear: Checking state...');
                log(`  ‚Ä¢ Canvas shapes: ${shapesAfter} (should be 0)`);
                log(`  ‚Ä¢ HTML components: ${htmlComponentsAfter} (should be 0)`);
                log(`  ‚Ä¢ Selected elements: ${selectedElementsAfter} (should be 0)`);
                log(`  ‚Ä¢ Current tool: ${canvasMaker.currentTool || 'none'}`);
                log(`  ‚Ä¢ Is dragging: ${canvasMaker.isDragging}`);
                log(`  ‚Ä¢ Is editing component: ${canvasMaker.editingComponentId || 'none'}`);
                
                // Verify success
                const success = shapesAfter === 0 && htmlComponentsAfter === 0 && selectedElementsAfter === 0;
                if (success) {
                    log('‚úÖ ENHANCED CLEAR() TEST PASSED - Everything cleared successfully!');
                } else {
                    log('‚ùå ENHANCED CLEAR() TEST FAILED - Some elements remain');
                }
                
                componentCount = 0;
            }, 100);
        }
        
        // Test zoom functionality
        function testZoom() {
            log('Testing zoom - zooming in...');
            canvasMaker.zoomIn();
            
            setTimeout(() => {
                log('Zooming out...');
                canvasMaker.zoomOut();
            }, 1000);
        }
        
        // Test pan functionality  
        function testPan() {
            log('Testing pan - moving camera...');
            const camera = canvasMaker.activeCanvasContext.camera;
            const originalX = camera.x;
            const originalY = camera.y;
            
            // Pan right and down
            camera.x += 100;
            camera.y += 50;
            canvasMaker.redrawCanvas();
            
            setTimeout(() => {
                log('Returning to original position...');
                camera.x = originalX;
                camera.y = originalY;
                canvasMaker.redrawCanvas();
            }, 1000);
        }
        
        // Add a form with content that overflows the container
        function addScrollableForm() {
            componentCount++;
            const offsetX = componentCount === 1 ? 0 : (Math.random() - 0.5) * 300;
            const offsetY = componentCount === 1 ? 0 : (Math.random() - 0.5) * 200;
            
            // Create large form content that will overflow
            const formHTML = `
                <div style="padding: 10px; background: white; border-radius: 6px; box-sizing: border-box; min-height: 100%;">
                    <h3 style="margin: 0 0 10px 0; color: #333;">Large Form ${componentCount}</h3>
                    <p style="margin-bottom: 10px; font-size: 12px;">This form has more content than can fit in the container. Double-click to enable scrolling.</p>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; font-weight: bold; margin-bottom: 5px;">Name:</label>
                        <input type="text" placeholder="Enter your name" style="width: 100%; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; font-weight: bold; margin-bottom: 5px;">Email:</label>
                        <input type="email" placeholder="Enter your email" style="width: 100%; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; font-weight: bold; margin-bottom: 5px;">Message:</label>
                        <textarea placeholder="Enter your message here..." style="width: 100%; height: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 3px; resize: none;"></textarea>
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                            <input type="checkbox" style="margin-right: 5px;"> I agree to the terms and conditions
                        </label>
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; font-weight: bold; margin-bottom: 5px;">Priority:</label>
                        <select style="width: 100%; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                            <option>Low</option>
                            <option>Medium</option>
                            <option>High</option>
                            <option>Urgent</option>
                        </select>
                    </div>
                    
                    <div style="display: flex; gap: 10px;">
                        <button style="flex: 1; padding: 8px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">Submit</button>
                        <button style="flex: 1; padding: 8px; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer;">Cancel</button>
                    </div>
                    
                    <div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 3px; font-size: 11px; color: #666;">
                        This is additional content to demonstrate scrolling functionality when the content exceeds the container height.
                    </div>
                </div>
            `;
            
            const shape = canvasMaker.addReactComponentWithHTML(offsetX, offsetY, 250, 200, formHTML, {
                id: 'scrollable-form-' + componentCount,
                fill: '#f8f9fa',
                coordinateSystem: 'center'
            });
            
            log(`Added large scrollable form #${componentCount} - Double-click to enable scrolling`);
            return shape;
        }
        
        // Test scrollable features
        function testScrollableFeatures() {
            log('üîÑ TESTING SCROLLABLE FEATURES');
            
            // Find all React components
            const reactShapes = canvasMaker.activeCanvasContext.shapes.filter(s => s.type === 'reactComponent');
            
            if (reactShapes.length === 0) {
                log('‚ùå No React components found. Add some components first.');
                return;
            }
            
            reactShapes.forEach((shape, index) => {
                log(`- Component ${shape.id}:`);
                
                // Check overflow info
                const overflowInfo = canvasMaker.getComponentOverflowInfo(shape.id);
                const hasOverflow = canvasMaker.hasComponentOverflow(shape.id);
                
                log(`  ‚Ä¢ Has overflow: ${hasOverflow}`);
                if (overflowInfo) {
                    log(`  ‚Ä¢ Content size: ${overflowInfo.scrollWidth}x${overflowInfo.scrollHeight}`);
                    log(`  ‚Ä¢ Container size: ${overflowInfo.clientWidth}x${overflowInfo.clientHeight}`);
                    log(`  ‚Ä¢ Horizontal overflow: ${overflowInfo.horizontal}`);
                    log(`  ‚Ä¢ Vertical overflow: ${overflowInfo.vertical}`);
                    
                    // Test setting scrollable size for components with overflow
                    if (hasOverflow) {
                        log(`  ‚Ä¢ Setting custom scrollable size for ${shape.id}`);
                        const success = canvasMaker.setComponentScrollableSize(shape.id, 200, 150);
                        log(`  ‚Ä¢ Size update ${success ? 'succeeded' : 'failed'}`);
                    }
                } else {
                    log(`  ‚Ä¢ No overflow info available`);
                }
            });
            
            log('‚úÖ Scrollable features test completed. Double-click components with overflow to test scrolling!');
        }
        
        // Test persistence features (export/import state)
        function testPersistence() {
            log('üíæ TESTING PERSISTENCE FEATURES');
            
            // Check if there's content to export
            const shapes = canvasMaker.activeCanvasContext.shapes.length;
            const htmlComponents = canvasMaker.getAllHTMLComponentsData().length;
            
            if (shapes === 0 && htmlComponents === 0) {
                log('‚ö†Ô∏è  No content to test persistence. Add some components first.');
                return;
            }
            
            log(`- Current content: ${shapes} shapes, ${htmlComponents} HTML components`);
            
            // Test individual component data access
            log('- Testing individual component data access:');
            canvasMaker.activeCanvasContext.shapes
                .filter(s => s.type === 'reactComponent')
                .slice(0, 2) // Test first 2 components
                .forEach(shape => {
                    const data = canvasMaker.getHTMLComponentData(shape.id);
                    log(`  ‚Ä¢ ${shape.id}: ${data ? 'SUCCESS' : 'FAILED'} (size: ${data ? data.width + 'x' + data.height : 'N/A'})`);
                });
            
            // Export state
            log('- Exporting canvas state...');
            const exportedState = canvasMaker.exportState();
            log(`  ‚Ä¢ Exported ${exportedState.shapes.length} shapes, ${exportedState.htmlComponents.length} HTML components`);
            log(`  ‚Ä¢ State version: ${exportedState.version}, timestamp: ${new Date(exportedState.timestamp).toLocaleTimeString()}`);
            
            // Test persistence filter
            log('- Setting up persistence filter (exclude buttons):');
            canvasMaker.setPersistenceFilter((item, type) => {
                if (type === 'htmlComponent' && item.id && item.id.includes('button')) {
                    log(`  ‚Ä¢ Filtering out: ${item.id}`);
                    return false;
                }
                return true;
            });
            
            const filteredState = canvasMaker.exportState();
            log(`  ‚Ä¢ Filtered export: ${filteredState.htmlComponents.length} HTML components (${exportedState.htmlComponents.length - filteredState.htmlComponents.length} buttons filtered out)`);
            
            // Clear filter for import test
            canvasMaker.setPersistenceFilter(null);
            
            // Store current camera position
            const originalCamera = { ...canvasMaker.activeCanvasContext.camera };
            
            // Modify camera to test restoration
            canvasMaker.activeCanvasContext.camera.x = 100;
            canvasMaker.activeCanvasContext.camera.y = 50;
            canvasMaker.activeCanvasContext.camera.zoom = 1.5;
            canvasMaker.redrawCanvas();
            
            setTimeout(() => {
                log('- Importing previous state (should restore original camera and content)...');
                const success = canvasMaker.importState(exportedState);
                log(`  ‚Ä¢ Import ${success ? 'succeeded' : 'failed'}`);
                
                if (success) {
                    const restoredShapes = canvasMaker.activeCanvasContext.shapes.length;
                    const restoredComponents = canvasMaker.getAllHTMLComponentsData().length;
                    log(`  ‚Ä¢ Restored: ${restoredShapes} shapes, ${restoredComponents} HTML components`);
                    
                    const camera = canvasMaker.activeCanvasContext.camera;
                    log(`  ‚Ä¢ Camera restored: (${camera.x}, ${camera.y}) zoom: ${camera.zoom}`);
                }
                
                log('‚úÖ Persistence test completed!');
            }, 1000);
        }
        
        // Test granular clear methods
        function testGranularClear() {
            log('üßπ TESTING GRANULAR CLEAR METHODS');
            
            // Ensure we have mixed content
            if (canvasMaker.activeCanvasContext.shapes.length === 0) {
                log('‚ö†Ô∏è  Adding test content for granular clear demo...');
                addButton();
                addCard();
                
                // Add some canvas shapes
                canvasMaker.activeCanvasContext.shapes.push({
                    type: 'rectangle',
                    x: 50,
                    y: 50,
                    width: 100,
                    height: 60,
                    strokeColor: '#333',
                    fillColor: '#f0f0f0'
                });
                
                canvasMaker.activeCanvasContext.shapes.push({
                    type: 'circle',
                    x: -50,
                    y: -50,
                    radius: 40,
                    strokeColor: '#007bff',
                    fillColor: 'transparent'
                });
                
                canvasMaker.redrawCanvas();
                
                setTimeout(() => testGranularClearActual(), 500);
                return;
            }
            
            testGranularClearActual();
        }
        
        function testGranularClearActual() {
            const initialShapes = canvasMaker.activeCanvasContext.shapes.length;
            const initialHtmlComponents = canvasMaker.getAllHTMLComponentsData().length;
            const initialCanvasShapes = canvasMaker.activeCanvasContext.shapes.filter(s => s.type !== 'reactComponent').length;
            
            log(`- Initial content: ${initialShapes} total shapes (${initialHtmlComponents} HTML, ${initialCanvasShapes} canvas shapes)`);
            
            // Test 1: Clear only canvas shapes
            log('- Test 1: clearShapes() - should keep HTML components');
            canvasMaker.clearShapes();
            
            setTimeout(() => {
                const afterShapes = canvasMaker.activeCanvasContext.shapes.length;
                const afterHtmlComponents = canvasMaker.getAllHTMLComponentsData().length;
                log(`  ‚Ä¢ After clearShapes(): ${afterShapes} shapes (${afterHtmlComponents} HTML components remain)`);
                log(`  ‚Ä¢ ${afterHtmlComponents === initialHtmlComponents ? '‚úÖ SUCCESS' : '‚ùå FAILED'} - HTML components preserved`);
                
                // Add canvas shapes back for next test
                canvasMaker.activeCanvasContext.shapes.push({
                    type: 'rectangle',
                    x: 0,
                    y: 100,
                    width: 80,
                    height: 40,
                    strokeColor: '#28a745',
                    fillColor: 'transparent'
                });
                canvasMaker.redrawCanvas();
                
                // Test 2: Clear only HTML components
                setTimeout(() => {
                    log('- Test 2: clearHTMLComponents() - should keep canvas shapes');
                    canvasMaker.clearHTMLComponents();
                    
                    setTimeout(() => {
                        const finalShapes = canvasMaker.activeCanvasContext.shapes.length;
                        const finalHtmlComponents = canvasMaker.getAllHTMLComponentsData().length;
                        const finalCanvasShapes = canvasMaker.activeCanvasContext.shapes.filter(s => s.type !== 'reactComponent').length;
                        
                        log(`  ‚Ä¢ After clearHTMLComponents(): ${finalShapes} shapes (${finalHtmlComponents} HTML, ${finalCanvasShapes} canvas)`);
                        log(`  ‚Ä¢ ${finalHtmlComponents === 0 ? '‚úÖ SUCCESS' : '‚ùå FAILED'} - HTML components cleared`);
                        log(`  ‚Ä¢ ${finalCanvasShapes > 0 ? '‚úÖ SUCCESS' : '‚ùå FAILED'} - Canvas shapes preserved`);
                        
                        // Test 3: Clear all
                        setTimeout(() => {
                            log('- Test 3: clearAll() - should clear everything');
                            canvasMaker.clearAll();
                            
                            const allShapes = canvasMaker.activeCanvasContext.shapes.length;
                            const allHtml = canvasMaker.getAllHTMLComponentsData().length;
                            log(`  ‚Ä¢ After clearAll(): ${allShapes} shapes, ${allHtml} HTML components`);
                            log(`  ‚Ä¢ ${allShapes === 0 && allHtml === 0 ? '‚úÖ SUCCESS' : '‚ùå FAILED'} - Everything cleared`);
                            
                            componentCount = 0;
                            log('‚úÖ Granular clear methods test completed!');
                        }, 500);
                    }, 500);
                }, 1000);
            }, 500);
        }
        
        // Test resize limits and constraints
        function testResizeLimits() {
            log('üìè TESTING RESIZE LIMITS & CONSTRAINTS');
            
            // Clear existing components for clean test
            canvasMaker.clearHTMLComponents();
            
            log('- Setting up test components with different constraint types...');
            
            // 1. Create a component with default constraints
            const defaultComponent = addButton();
            log(`  ‚Ä¢ Default component created: ${defaultComponent.id} (default constraints apply)`);
            
            // 2. Create a component with strict size limits (small range)
            componentCount++;
            const strictHTML = `<div style="padding: 10px; background: #ff6b6b; color: white; text-align: center; border-radius: 4px;">
                <strong>Strict Limits</strong><br>
                <small>Min: 80x40, Max: 150x80</small>
            </div>`;
            
            const strictComponent = canvasMaker.addReactComponentWithHTML(-100, -50, 120, 60, strictHTML, {
                id: 'strict-component-' + componentCount,
                coordinateSystem: 'center',
                resizeConstraints: {
                    minWidth: 80,
                    minHeight: 40,
                    maxWidth: 150,
                    maxHeight: 80
                }
            });
            
            log(`  ‚Ä¢ Strict component created: ${strictComponent.id} (80x40 to 150x80)`);
            
            // 3. Create a component with relaxed limits (large range)
            componentCount++;
            const relaxedHTML = `<div style="padding: 10px; background: #28a745; color: white; text-align: center; border-radius: 4px;">
                <strong>Relaxed Limits</strong><br>
                <small>Min: 100x60, Max: 400x300</small>
            </div>`;
            
            const relaxedComponent = canvasMaker.addReactComponentWithHTML(100, -50, 200, 100, relaxedHTML, {
                id: 'relaxed-component-' + componentCount,
                coordinateSystem: 'center',
                resizeConstraints: {
                    minWidth: 100,
                    minHeight: 60,
                    maxWidth: 400,
                    maxHeight: 300
                }
            });
            
            log(`  ‚Ä¢ Relaxed component created: ${relaxedComponent.id} (100x60 to 400x300)`);
            
            // 4. Set constraints on an existing component
            canvasMaker.setComponentResizeConstraints(defaultComponent.id, {
                minWidth: 60,
                minHeight: 25,
                maxWidth: 200,
                maxHeight: 100
            });
            
            log(`  ‚Ä¢ Updated constraints for ${defaultComponent.id} (60x25 to 200x100)`);
            
            // 5. Test global constraint changes
            log('- Setting global constraints (affects all components without specific constraints)...');
            canvasMaker.setResizeConstraints('reactComponent', {
                minWidth: 75,
                minHeight: 35,
                maxWidth: 300,
                maxHeight: 200
            });
            
            // Show current constraints for each component
            log('- Current constraint summary:');
            [defaultComponent, strictComponent, relaxedComponent].forEach(comp => {
                const constraints = canvasMaker.getResizeConstraints(comp.type, comp);
                log(`  ‚Ä¢ ${comp.id}: ${constraints.minWidth}x${constraints.minHeight} to ${constraints.maxWidth}x${constraints.maxHeight}`);
            });
            
            // Add visual feedback
            setTimeout(() => {
                log('- üéØ TEST INSTRUCTIONS:');
                log('  1. Try to resize each component beyond its limits');
                log('  2. Red component (strict): Very narrow size range');
                log('  3. Green component (relaxed): Wide size range');
                log('  4. Blue component (modified): Custom constraints applied');
                log('  5. Components should stop resizing at min/max limits');
                log('  6. Position should adjust properly when hitting limits');
                
                log('‚úÖ Resize limits test setup completed!');
                log('üí° TIP: Select a component and try dragging the resize handles to test constraints');
            }, 100);
        }
        
        // Test external constraint API with warnings
        function testExternalConstraintAPI() {
            log('‚öôÔ∏è TESTING EXTERNAL CONSTRAINT API');
            
            // Ensure we have at least one component
            if (canvasMaker.getAllHTMLComponentsData().length === 0) {
                log('- Adding a test component first...');
                addButton();
            }
            
            log('- Current global constraints:');
            const currentGlobal = canvasMaker.getCurrentResizeConstraints('global');
            log(`  ‚Ä¢ Global: ${currentGlobal.minWidth}x${currentGlobal.minHeight} to ${currentGlobal.maxWidth}x${currentGlobal.maxHeight}`);
            
            const currentHTML = canvasMaker.getCurrentResizeConstraints('reactComponent');
            log(`  ‚Ä¢ HTML Components: ${currentHTML.minWidth}x${currentHTML.minHeight} to ${currentHTML.maxWidth}x${currentHTML.maxHeight}`);
            
            log('');
            log('- Testing external API methods (check console for detailed warnings)...');
            
            // Test 1: Set reasonable constraints (should show info messages)
            log('1Ô∏è‚É£ Setting reasonable HTML component constraints...');
            canvasMaker.setHTMLComponentConstraints({
                minWidth: 80,
                minHeight: 50,
                maxWidth: 500,
                maxHeight: 400
            });
            
            setTimeout(() => {
                // Test 2: Set concerning constraints (should show warnings)
                log('2Ô∏è‚É£ Setting concerning constraints (very small min, very large max)...');
                canvasMaker.setHTMLComponentConstraints({
                    minWidth: 5,    // Very small - will trigger warning
                    minHeight: 3,   // Very small - will trigger warning
                    maxWidth: 3000, // Very large - will trigger warning
                    maxHeight: 2500 // Very large - will trigger warning
                });
                
                setTimeout(() => {
                    // Test 3: Set invalid constraints (min >= max)
                    log('3Ô∏è‚É£ Setting invalid constraints (min >= max)...');
                    canvasMaker.setHTMLComponentConstraints({
                        minWidth: 200,
                        maxWidth: 150,  // Less than min - will trigger error
                        minHeight: 100,
                        maxHeight: 80   // Less than min - will trigger error
                    });
                    
                    setTimeout(() => {
                        // Test 4: Remove all constraints (should show big warning)
                        log('4Ô∏è‚É£ Removing ALL resize constraints (check console for warnings)...');
                        canvasMaker.removeResizeConstraints('reactComponent');
                        
                        setTimeout(() => {
                            // Test 5: Suppress warnings
                            log('5Ô∏è‚É£ Setting constraints with warnings suppressed...');
                            canvasMaker.setHTMLComponentConstraints({
                                minWidth: 2,
                                maxWidth: 4000
                            }, { suppressWarnings: true });
                            
                            setTimeout(() => {
                                // Test 6: Restore reasonable defaults
                                log('6Ô∏è‚É£ Restoring reasonable defaults...');
                                canvasMaker.setHTMLComponentConstraints({
                                    minWidth: 50,
                                    minHeight: 30,
                                    maxWidth: 1500,
                                    maxHeight: 1000
                                });
                                
                                log('');
                                log('‚úÖ External constraint API test completed!');
                                log('üìã Summary of what happened:');
                                log('  ‚Ä¢ Reasonable constraints: Info messages in console');
                                log('  ‚Ä¢ Concerning values: Warning messages in console');
                                log('  ‚Ä¢ Invalid ranges: Error messages in console');
                                log('  ‚Ä¢ Removing constraints: Big warning about distortion risks');
                                log('  ‚Ä¢ Suppressed warnings: Silent operation');
                                log('  ‚Ä¢ Final restoration: Back to safe defaults');
                                log('');
                                log('üí° TIP: Check the browser console to see all warning messages!');
                            }, 1000);
                        }, 1000);
                    }, 1000);
                }, 1000);
            }, 1000);
        }
        
        // Logging function
        function log(message) {
            const logDiv = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `<span style="color: #666;">${time}:</span> ${message}`;
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[HTML-RENDER-TEST] ${message}`);
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeCanvas();
            
            // Add a demo component
            setTimeout(() => {
                addButton();
                addCard();
            }, 500);
        });
        
        // Monitor for HTML components
        setInterval(() => {
            if (canvasMaker && canvasMaker.htmlComponents) {
                const count = canvasMaker.htmlComponents.size;
                const status = document.querySelector('#component-status');
                if (!status) {
                    const statusDiv = document.createElement('div');
                    statusDiv.id = 'component-status';
                    statusDiv.style.cssText = 'position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 8px; border-radius: 4px; font-size: 12px;';
                    document.body.appendChild(statusDiv);
                }
                document.getElementById('component-status').textContent = `HTML Components: ${count}`;
            }
        }, 1000);
    </script>
</body>
</html>